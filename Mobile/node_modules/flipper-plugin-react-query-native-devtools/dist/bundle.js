var __BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=true,process=this.process||{},__METRO_GLOBAL_PREFIX__='';process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||"development";
(function (global) {
  "use strict";

  global.__r = metroRequire;
  global[`${__METRO_GLOBAL_PREFIX__}__d`] = define;
  global.__c = clear;
  global.__registerSegment = registerSegment;
  var modules = clear();
  const EMPTY = {};
  const {
    hasOwnProperty
  } = {};

  if (__DEV__) {
    global.$RefreshReg$ = () => {};

    global.$RefreshSig$ = () => type => type;
  }

  function clear() {
    modules = Object.create(null);
    return modules;
  }

  if (__DEV__) {
    var verboseNamesToModuleIds = Object.create(null);
    var initializingModuleIds = [];
  }

  function define(factory, moduleId, dependencyMap) {
    if (modules[moduleId] != null) {
      if (__DEV__) {
        const inverseDependencies = arguments[4];

        if (inverseDependencies) {
          global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
        }
      }

      return;
    }

    const mod = {
      dependencyMap,
      factory,
      hasError: false,
      importedAll: EMPTY,
      importedDefault: EMPTY,
      isInitialized: false,
      publicModule: {
        exports: {}
      }
    };
    modules[moduleId] = mod;

    if (__DEV__) {
      mod.hot = createHotReloadingObject();
      const verboseName = arguments[3];

      if (verboseName) {
        mod.verboseName = verboseName;
        verboseNamesToModuleIds[verboseName] = moduleId;
      }
    }
  }

  function metroRequire(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      const verboseName = moduleId;
      moduleId = verboseNamesToModuleIds[verboseName];

      if (moduleId == null) {
        throw new Error(`Unknown named module: "${verboseName}"`);
      } else {
        console.warn(`Requiring module "${verboseName}" by name is only supported for ` + "debugging purposes and will BREAK IN PRODUCTION!");
      }
    }

    const moduleIdReallyIsNumber = moduleId;

    if (__DEV__) {
      const initializingIndex = initializingModuleIds.indexOf(moduleIdReallyIsNumber);

      if (initializingIndex !== -1) {
        const cycle = initializingModuleIds.slice(initializingIndex).map(id => modules[id] ? modules[id].verboseName : "[unknown]");
        cycle.push(cycle[0]);
        console.warn(`Require cycle: ${cycle.join(" -> ")}\n\n` + "Require cycles are allowed, but can result in uninitialized values. " + "Consider refactoring to remove the need for a cycle.");
      }
    }

    const module = modules[moduleIdReallyIsNumber];
    return module && module.isInitialized ? module.publicModule.exports : guardedLoadModule(moduleIdReallyIsNumber, module);
  }

  function metroImportDefault(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      const verboseName = moduleId;
      moduleId = verboseNamesToModuleIds[verboseName];
    }

    const moduleIdReallyIsNumber = moduleId;

    if (modules[moduleIdReallyIsNumber] && modules[moduleIdReallyIsNumber].importedDefault !== EMPTY) {
      return modules[moduleIdReallyIsNumber].importedDefault;
    }

    const exports = metroRequire(moduleIdReallyIsNumber);
    const importedDefault = exports && exports.__esModule ? exports.default : exports;
    return modules[moduleIdReallyIsNumber].importedDefault = importedDefault;
  }

  metroRequire.importDefault = metroImportDefault;

  function metroImportAll(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      const verboseName = moduleId;
      moduleId = verboseNamesToModuleIds[verboseName];
    }

    const moduleIdReallyIsNumber = moduleId;

    if (modules[moduleIdReallyIsNumber] && modules[moduleIdReallyIsNumber].importedAll !== EMPTY) {
      return modules[moduleIdReallyIsNumber].importedAll;
    }

    const exports = metroRequire(moduleIdReallyIsNumber);
    let importedAll;

    if (exports && exports.__esModule) {
      importedAll = exports;
    } else {
      importedAll = {};

      if (exports) {
        for (const key in exports) {
          if (hasOwnProperty.call(exports, key)) {
            importedAll[key] = exports[key];
          }
        }
      }

      importedAll.default = exports;
    }

    return modules[moduleIdReallyIsNumber].importedAll = importedAll;
  }

  metroRequire.importAll = metroImportAll;
  let inGuard = false;

  function guardedLoadModule(moduleId, module) {
    if (!inGuard && global.ErrorUtils) {
      inGuard = true;
      let returnValue;

      try {
        returnValue = loadModuleImplementation(moduleId, module);
      } catch (e) {
        global.ErrorUtils.reportFatalError(e);
      }

      inGuard = false;
      return returnValue;
    } else {
      return loadModuleImplementation(moduleId, module);
    }
  }

  const ID_MASK_SHIFT = 16;
  const LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;

  function unpackModuleId(moduleId) {
    const segmentId = moduleId >>> ID_MASK_SHIFT;
    const localId = moduleId & LOCAL_ID_MASK;
    return {
      segmentId,
      localId
    };
  }

  metroRequire.unpackModuleId = unpackModuleId;

  function packModuleId(value) {
    return (value.segmentId << ID_MASK_SHIFT) + value.localId;
  }

  metroRequire.packModuleId = packModuleId;
  const moduleDefinersBySegmentID = [];
  const definingSegmentByModuleID = new Map();

  function registerSegment(segmentId, moduleDefiner, moduleIds) {
    moduleDefinersBySegmentID[segmentId] = moduleDefiner;

    if (__DEV__) {
      if (segmentId === 0 && moduleIds) {
        throw new Error("registerSegment: Expected moduleIds to be null for main segment");
      }

      if (segmentId !== 0 && !moduleIds) {
        throw new Error("registerSegment: Expected moduleIds to be passed for segment #" + segmentId);
      }
    }

    if (moduleIds) {
      moduleIds.forEach(moduleId => {
        if (!modules[moduleId] && !definingSegmentByModuleID.has(moduleId)) {
          definingSegmentByModuleID.set(moduleId, segmentId);
        }
      });
    }
  }

  function loadModuleImplementation(moduleId, module) {
    if (!module && moduleDefinersBySegmentID.length > 0) {
      var _definingSegmentByMod;

      const segmentId = (_definingSegmentByMod = definingSegmentByModuleID.get(moduleId)) !== null && _definingSegmentByMod !== void 0 ? _definingSegmentByMod : 0;
      const definer = moduleDefinersBySegmentID[segmentId];

      if (definer != null) {
        definer(moduleId);
        module = modules[moduleId];
        definingSegmentByModuleID.delete(moduleId);
      }
    }

    const nativeRequire = global.nativeRequire;

    if (!module && nativeRequire) {
      const {
        segmentId,
        localId
      } = unpackModuleId(moduleId);
      nativeRequire(localId, segmentId);
      module = modules[moduleId];
    }

    if (!module) {
      throw unknownModuleError(moduleId);
    }

    if (module.hasError) {
      throw moduleThrewError(moduleId, module.error);
    }

    if (__DEV__) {
      var Systrace = requireSystrace();
      var Refresh = requireRefresh();
    }

    module.isInitialized = true;
    const {
      factory,
      dependencyMap
    } = module;

    if (__DEV__) {
      initializingModuleIds.push(moduleId);
    }

    try {
      if (__DEV__) {
        Systrace.beginEvent("JS_require_" + (module.verboseName || moduleId));
      }

      const moduleObject = module.publicModule;

      if (__DEV__) {
        moduleObject.hot = module.hot;
        var prevRefreshReg = global.$RefreshReg$;
        var prevRefreshSig = global.$RefreshSig$;

        if (Refresh != null) {
          const RefreshRuntime = Refresh;

          global.$RefreshReg$ = (type, id) => {
            RefreshRuntime.register(type, moduleId + " " + id);
          };

          global.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
        }
      }

      moduleObject.id = moduleId;
      factory(global, metroRequire, metroImportDefault, metroImportAll, moduleObject, moduleObject.exports, dependencyMap);

      if (!__DEV__) {
        module.factory = undefined;
        module.dependencyMap = undefined;
      }

      if (__DEV__) {
        Systrace.endEvent();

        if (Refresh != null) {
          registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);
        }
      }

      return moduleObject.exports;
    } catch (e) {
      module.hasError = true;
      module.error = e;
      module.isInitialized = false;
      module.publicModule.exports = undefined;
      throw e;
    } finally {
      if (__DEV__) {
        if (initializingModuleIds.pop() !== moduleId) {
          throw new Error("initializingModuleIds is corrupt; something is terribly wrong");
        }

        global.$RefreshReg$ = prevRefreshReg;
        global.$RefreshSig$ = prevRefreshSig;
      }
    }
  }

  function unknownModuleError(id) {
    let message = 'Requiring unknown module "' + id + '".';

    if (__DEV__) {
      message += " If you are sure the module exists, try restarting Metro. " + "You may also want to run `yarn` or `npm install`.";
    }

    return Error(message);
  }

  function moduleThrewError(id, error) {
    const displayName = __DEV__ && modules[id] && modules[id].verboseName || id;
    return Error('Requiring module "' + displayName + '", which threw an exception: ' + error);
  }

  if (__DEV__) {
    metroRequire.Systrace = {
      beginEvent: () => {},
      endEvent: () => {}
    };

    metroRequire.getModules = () => {
      return modules;
    };

    var createHotReloadingObject = function () {
      const hot = {
        _acceptCallback: null,
        _disposeCallback: null,
        _didAccept: false,
        accept: callback => {
          hot._didAccept = true;
          hot._acceptCallback = callback;
        },
        dispose: callback => {
          hot._disposeCallback = callback;
        }
      };
      return hot;
    };

    let reactRefreshTimeout = null;

    const metroHotUpdateModule = function (id, factory, dependencyMap, inverseDependencies) {
      const mod = modules[id];

      if (!mod) {
        if (factory) {
          return;
        }

        throw unknownModuleError(id);
      }

      if (!mod.hasError && !mod.isInitialized) {
        mod.factory = factory;
        mod.dependencyMap = dependencyMap;
        return;
      }

      const Refresh = requireRefresh();
      const refreshBoundaryIDs = new Set();
      let didBailOut = false;
      const updatedModuleIDs = topologicalSort([id], pendingID => {
        const pendingModule = modules[pendingID];

        if (pendingModule == null) {
          return [];
        }

        const pendingHot = pendingModule.hot;

        if (pendingHot == null) {
          throw new Error("[Refresh] Expected module.hot to always exist in DEV.");
        }

        let canAccept = pendingHot._didAccept;

        if (!canAccept && Refresh != null) {
          const isBoundary = isReactRefreshBoundary(Refresh, pendingModule.publicModule.exports);

          if (isBoundary) {
            canAccept = true;
            refreshBoundaryIDs.add(pendingID);
          }
        }

        if (canAccept) {
          return [];
        }

        const parentIDs = inverseDependencies[pendingID];

        if (parentIDs.length === 0) {
          performFullRefresh("No root boundary", {
            source: mod,
            failed: pendingModule
          });
          didBailOut = true;
          return [];
        }

        return parentIDs;
      }, () => didBailOut).reverse();

      if (didBailOut) {
        return;
      }

      const seenModuleIDs = new Set();

      for (let i = 0; i < updatedModuleIDs.length; i++) {
        const updatedID = updatedModuleIDs[i];

        if (seenModuleIDs.has(updatedID)) {
          continue;
        }

        seenModuleIDs.add(updatedID);
        const updatedMod = modules[updatedID];

        if (updatedMod == null) {
          throw new Error("[Refresh] Expected to find the updated module.");
        }

        const prevExports = updatedMod.publicModule.exports;
        const didError = runUpdatedModule(updatedID, updatedID === id ? factory : undefined, updatedID === id ? dependencyMap : undefined);
        const nextExports = updatedMod.publicModule.exports;

        if (didError) {
          return;
        }

        if (refreshBoundaryIDs.has(updatedID)) {
          const isNoLongerABoundary = !isReactRefreshBoundary(Refresh, nextExports);
          const didInvalidate = shouldInvalidateReactRefreshBoundary(Refresh, prevExports, nextExports);

          if (isNoLongerABoundary || didInvalidate) {
            const parentIDs = inverseDependencies[updatedID];

            if (parentIDs.length === 0) {
              performFullRefresh(isNoLongerABoundary ? "No longer a boundary" : "Invalidated boundary", {
                source: mod,
                failed: updatedMod
              });
              return;
            }

            for (let j = 0; j < parentIDs.length; j++) {
              const parentID = parentIDs[j];
              const parentMod = modules[parentID];

              if (parentMod == null) {
                throw new Error("[Refresh] Expected to find parent module.");
              }

              const canAcceptParent = isReactRefreshBoundary(Refresh, parentMod.publicModule.exports);

              if (canAcceptParent) {
                refreshBoundaryIDs.add(parentID);
                updatedModuleIDs.push(parentID);
              } else {
                performFullRefresh("Invalidated boundary", {
                  source: mod,
                  failed: parentMod
                });
                return;
              }
            }
          }
        }
      }

      if (Refresh != null) {
        if (reactRefreshTimeout == null) {
          reactRefreshTimeout = setTimeout(() => {
            reactRefreshTimeout = null;
            Refresh.performReactRefresh();
          }, 30);
        }
      }
    };

    const topologicalSort = function (roots, getEdges, earlyStop) {
      const result = [];
      const visited = new Set();

      function traverseDependentNodes(node) {
        visited.add(node);
        const dependentNodes = getEdges(node);

        if (earlyStop(node)) {
          return;
        }

        dependentNodes.forEach(dependent => {
          if (visited.has(dependent)) {
            return;
          }

          traverseDependentNodes(dependent);
        });
        result.push(node);
      }

      roots.forEach(root => {
        if (!visited.has(root)) {
          traverseDependentNodes(root);
        }
      });
      return result;
    };

    const runUpdatedModule = function (id, factory, dependencyMap) {
      const mod = modules[id];

      if (mod == null) {
        throw new Error("[Refresh] Expected to find the module.");
      }

      const {
        hot
      } = mod;

      if (!hot) {
        throw new Error("[Refresh] Expected module.hot to always exist in DEV.");
      }

      if (hot._disposeCallback) {
        try {
          hot._disposeCallback();
        } catch (error) {
          console.error(`Error while calling dispose handler for module ${id}: `, error);
        }
      }

      if (factory) {
        mod.factory = factory;
      }

      if (dependencyMap) {
        mod.dependencyMap = dependencyMap;
      }

      mod.hasError = false;
      mod.error = undefined;
      mod.importedAll = EMPTY;
      mod.importedDefault = EMPTY;
      mod.isInitialized = false;
      const prevExports = mod.publicModule.exports;
      mod.publicModule.exports = {};
      hot._didAccept = false;
      hot._acceptCallback = null;
      hot._disposeCallback = null;
      metroRequire(id);

      if (mod.hasError) {
        mod.hasError = false;
        mod.isInitialized = true;
        mod.error = null;
        mod.publicModule.exports = prevExports;
        return true;
      }

      if (hot._acceptCallback) {
        try {
          hot._acceptCallback();
        } catch (error) {
          console.error(`Error while calling accept handler for module ${id}: `, error);
        }
      }

      return false;
    };

    const performFullRefresh = (reason, modules) => {
      if (typeof window !== "undefined" && window.location != null && typeof window.location.reload === "function") {
        window.location.reload();
      } else {
        const Refresh = requireRefresh();

        if (Refresh != null) {
          var _modules$source$verbo, _modules$source, _modules$failed$verbo, _modules$failed;

          const sourceName = (_modules$source$verbo = (_modules$source = modules.source) === null || _modules$source === void 0 ? void 0 : _modules$source.verboseName) !== null && _modules$source$verbo !== void 0 ? _modules$source$verbo : "unknown";
          const failedName = (_modules$failed$verbo = (_modules$failed = modules.failed) === null || _modules$failed === void 0 ? void 0 : _modules$failed.verboseName) !== null && _modules$failed$verbo !== void 0 ? _modules$failed$verbo : "unknown";
          Refresh.performFullRefresh(`Fast Refresh - ${reason} <${sourceName}> <${failedName}>`);
        } else {
          console.warn("Could not reload the application after an edit.");
        }
      }
    };

    var isReactRefreshBoundary = function (Refresh, moduleExports) {
      if (Refresh.isLikelyComponentType(moduleExports)) {
        return true;
      }

      if (moduleExports == null || typeof moduleExports !== "object") {
        return false;
      }

      let hasExports = false;
      let areAllExportsComponents = true;

      for (const key in moduleExports) {
        hasExports = true;

        if (key === "__esModule") {
          continue;
        }

        const desc = Object.getOwnPropertyDescriptor(moduleExports, key);

        if (desc && desc.get) {
          return false;
        }

        const exportValue = moduleExports[key];

        if (!Refresh.isLikelyComponentType(exportValue)) {
          areAllExportsComponents = false;
        }
      }

      return hasExports && areAllExportsComponents;
    };

    var shouldInvalidateReactRefreshBoundary = (Refresh, prevExports, nextExports) => {
      const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);
      const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);

      if (prevSignature.length !== nextSignature.length) {
        return true;
      }

      for (let i = 0; i < nextSignature.length; i++) {
        if (prevSignature[i] !== nextSignature[i]) {
          return true;
        }
      }

      return false;
    };

    var getRefreshBoundarySignature = (Refresh, moduleExports) => {
      const signature = [];
      signature.push(Refresh.getFamilyByType(moduleExports));

      if (moduleExports == null || typeof moduleExports !== "object") {
        return signature;
      }

      for (const key in moduleExports) {
        if (key === "__esModule") {
          continue;
        }

        const desc = Object.getOwnPropertyDescriptor(moduleExports, key);

        if (desc && desc.get) {
          continue;
        }

        const exportValue = moduleExports[key];
        signature.push(key);
        signature.push(Refresh.getFamilyByType(exportValue));
      }

      return signature;
    };

    var registerExportsForReactRefresh = (Refresh, moduleExports, moduleID) => {
      Refresh.register(moduleExports, moduleID + " %exports%");

      if (moduleExports == null || typeof moduleExports !== "object") {
        return;
      }

      for (const key in moduleExports) {
        const desc = Object.getOwnPropertyDescriptor(moduleExports, key);

        if (desc && desc.get) {
          continue;
        }

        const exportValue = moduleExports[key];
        const typeID = moduleID + " %exports% " + key;
        Refresh.register(exportValue, typeID);
      }
    };

    global.__accept = metroHotUpdateModule;
  }

  if (__DEV__) {
    var requireSystrace = function requireSystrace() {
      return global[__METRO_GLOBAL_PREFIX__ + "__SYSTRACE"] || metroRequire.Systrace;
    };

    var requireRefresh = function requireRefresh() {
      return global[__METRO_GLOBAL_PREFIX__ + "__ReactRefresh"] || metroRequire.Refresh;
    };
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.plugin = exports.Component = void 0;

  var _flatted = _$$_REQUIRE(_dependencyMap[0], "flatted");

  var _flipperPlugin = global.FlipperPlugin;

  var React = _interopRequireWildcard(global.React);

  var _QuerySidebar = _$$_REQUIRE(_dependencyMap[1], "./components/QuerySidebar");

  var _utils = _$$_REQUIRE(_dependencyMap[2], "./utils");

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  const extendQuery = query => {
    const extendedQuery = query;
    extendedQuery.status = query.state.status;
    extendedQuery.dataUpdateCount = query.state.dataUpdateCount;
    extendedQuery.observersCount = (0, _utils.getObserversCounter)(query);
    extendedQuery.isQueryActive = (0, _utils.isQueryActive)(query);
    return extendedQuery;
  };

  const plugin = client => {
    const queries = (0, _flipperPlugin.createDataSource)([], {
      key: 'queryHash'
    });
    const selectedQueryId = (0, _flipperPlugin.createState)(undefined);
    client.onMessage('queries', event => {
      queries.clear();
      selectedQueryId.set(undefined);
      (0, _flatted.parse)(event.queries).forEach(query => {
        queries.append(extendQuery(query));
      });
    });
    client.onMessage('queryCacheEvent', event => {
      var _selectedQueryId$get;

      const cashEvent = (0, _flatted.parse)(event.cashEvent);
      const {
        type,
        query,
        query: {
          queryHash
        }
      } = cashEvent;

      if (!type) {
        return;
      }

      switch (type) {
        case 'queryAdded':
          queries.append(extendQuery(query));
          break;

        case 'queryRemoved':
          queries.deleteByKey(queryHash);
          break;

        case 'queryUpdated':
        case 'observerAdded':
        case 'observerRemoved':
        case 'observerResultsUpdated':
          queries.upsert(extendQuery(query));

          if (((_selectedQueryId$get = selectedQueryId.get()) === null || _selectedQueryId$get === void 0 ? void 0 : _selectedQueryId$get.slice(11)) === queryHash) {
            selectedQueryId.set((0, _utils.makeQuerySelectionKey)(query));
          }

          break;

        default:
          break;
      }
    });

    const handleOnSelect = record => {
      const newSelectQueryId = record ? (0, _utils.makeQuerySelectionKey)(record) : undefined;
      selectedQueryId.set(newSelectQueryId);
    };

    const handleQueryRefetch = query => {
      client.send('queryRefetch', {
        queryHash: query.queryHash
      });
    };

    const handleQueryRemove = query => {
      queries.deleteByKey(query.queryHash);
      client.send('queryRemove', {
        queryHash: query.queryHash
      });
    };

    return {
      queries,
      selectedQueryId,
      handleOnSelect,
      handleQueryRefetch,
      handleQueryRemove
    };
  };

  exports.plugin = plugin;
  const columns = [{
    key: 'state',
    title: 'Data Updated At',
    width: 100,
    visible: true,
    formatters: [value => {
      return (0, _utils.formatTimestamp)(value.dataUpdatedAt);
    }]
  }, {
    key: 'status',
    title: 'Status',
    width: 80,
    visible: true,
    onRender: query => {
      return (0, _utils.getQueryStatusLabel)(query);
    }
  }, {
    key: 'dataUpdateCount',
    title: 'Data Updated Count',
    width: 40,
    visible: true
  }, {
    key: 'isQueryActive',
    title: 'isActive',
    width: 40,
    visible: true
  }, {
    key: 'observersCount',
    title: 'Observers',
    width: 40,
    visible: true
  }, {
    key: 'queryHash',
    title: 'Query Hash',
    wrap: true
  }];

  const Component = () => {
    const instance = (0, _flipperPlugin.usePlugin)(plugin);
    return global.React.createElement(_flipperPlugin.Layout.Container, {
      grow: true
    }, global.React.createElement(_flipperPlugin.DataTable, {
      dataSource: instance.queries,
      onSelect: instance.handleOnSelect,
      columns: columns,
      enableMultiSelect: false,
      enableAutoScroll: true
    }), global.React.createElement(_QuerySidebar.QuerySidebar, null));
  };

  exports.Component = Component;
},0,[1,2,3],"src/index.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.toJSON = exports.stringify = exports.parse = exports.fromJSON = void 0;
  const {
    parse: $parse,
    stringify: $stringify
  } = JSON;
  const {
    keys
  } = Object;
  const Primitive = String;
  const primitive = 'string';
  const ignore = {};
  const object = 'object';

  const noop = (_, value) => value;

  const primitives = value => value instanceof Primitive ? Primitive(value) : value;

  const Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;

  const revive = (input, parsed, output, $) => {
    const lazy = [];

    for (let ke = keys(output), {
      length
    } = ke, y = 0; y < length; y++) {
      const k = ke[y];
      const value = output[k];

      if (value instanceof Primitive) {
        const tmp = input[value];

        if (typeof tmp === object && !parsed.has(tmp)) {
          parsed.add(tmp);
          output[k] = ignore;
          lazy.push({
            k,
            a: [input, parsed, tmp, $]
          });
        } else output[k] = $.call(output, k, tmp);
      } else if (output[k] !== ignore) output[k] = $.call(output, k, value);
    }

    for (let {
      length
    } = lazy, i = 0; i < length; i++) {
      const {
        k,
        a
      } = lazy[i];
      output[k] = $.call(output, k, revive.apply(null, a));
    }

    return output;
  };

  const set = (known, input, value) => {
    const index = Primitive(input.push(value) - 1);
    known.set(value, index);
    return index;
  };

  const parse = (text, reviver) => {
    const input = $parse(text, Primitives).map(primitives);
    const value = input[0];
    const $ = reviver || noop;
    const tmp = typeof value === object && value ? revive(input, new Set(), value, $) : value;
    return $.call({
      '': tmp
    }, '', tmp);
  };

  exports.parse = parse;

  const stringify = (value, replacer, space) => {
    const $ = replacer && typeof replacer === object ? (k, v) => k === '' || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop;
    const known = new Map();
    const input = [];
    const output = [];
    let i = +set(known, input, $.call({
      '': value
    }, '', value));
    let firstRun = !i;

    while (i < input.length) {
      firstRun = true;
      output[i] = $stringify(input[i++], replace, space);
    }

    return '[' + output.join(',') + ']';

    function replace(key, value) {
      if (firstRun) {
        firstRun = !firstRun;
        return value;
      }

      const after = $.call(this, key, value);

      switch (typeof after) {
        case object:
          if (after === null) return after;

        case primitive:
          return known.get(after) || set(known, input, after);
      }

      return after;
    }
  };

  exports.stringify = stringify;

  const toJSON = any => $parse(stringify(any));

  exports.toJSON = toJSON;

  const fromJSON = any => parse($stringify(any));

  exports.fromJSON = fromJSON;
},1,[],"../../node_modules/flatted/esm/index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.QuerySidebar = void 0;
  var _antd = global.antd;
  var _flipperPlugin = global.FlipperPlugin;

  var _react = _interopRequireDefault(global.React);

  var _index = _$$_REQUIRE(_dependencyMap[0], "../index");

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const ContainerWithPaddings = (0, _flipperPlugin.styled)(_flipperPlugin.Layout.Container)({
    padding: '10px 5px'
  });

  const QuerySidebar = () => {
    var _query$state;

    const instance = (0, _flipperPlugin.usePlugin)(_index.plugin);
    const selectedQueryId = (0, _flipperPlugin.useValue)(instance.selectedQueryId);

    if (!selectedQueryId) {
      return null;
    }

    const query = instance.queries.getById(selectedQueryId.slice(11));

    if (!query) {
      return null;
    }

    return _react.default.createElement(_flipperPlugin.DetailSidebar, {
      width: 400
    }, _react.default.createElement(_flipperPlugin.Panel, {
      title: "Actions",
      collapsed: true
    }, _react.default.createElement(_flipperPlugin.Toolbar, null, _react.default.createElement(_antd.Button, {
      type: "primary",
      disabled: query.state.isFetching,
      onClick: () => {
        instance.handleQueryRefetch(query);
      }
    }, "Refetch"), _react.default.createElement(_antd.Button, {
      type: "default",
      danger: true,
      onClick: () => {
        instance.handleQueryRemove(query);
      }
    }, "Remove"))), _react.default.createElement(_flipperPlugin.Panel, {
      title: "Data Explorer",
      collapsed: true
    }, _react.default.createElement(ContainerWithPaddings, null, _react.default.createElement(_flipperPlugin.DataInspector, {
      data: ((_query$state = query.state) === null || _query$state === void 0 ? void 0 : _query$state.data) || {},
      expandRoot: true,
      collapsed: true
    }))), _react.default.createElement(_flipperPlugin.Panel, {
      title: "Query Explorer",
      collapsed: true
    }, _react.default.createElement(ContainerWithPaddings, null, _react.default.createElement(_flipperPlugin.DataInspector, {
      data: query,
      expandRoot: true,
      collapsed: true
    }))));
  };

  exports.QuerySidebar = QuerySidebar;
},2,[0],"src/components/QuerySidebar.tsx");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.formatTimestamp = formatTimestamp;
  exports.getObserversCounter = getObserversCounter;
  exports.getQueryStatusLabel = getQueryStatusLabel;
  exports.isQueryActive = isQueryActive;
  exports.makeQuerySelectionKey = makeQuerySelectionKey;

  var _padStart = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[0], "lodash/padStart"));

  var _nanoid = _$$_REQUIRE(_dependencyMap[1], "nanoid");

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function formatTimestamp(timestamp) {
    if (timestamp === 0) {
      return '-';
    }

    const date = new Date(timestamp);
    return `${(0, _padStart.default)(date.getHours().toString(), 2, '0')}:${(0, _padStart.default)(date.getMinutes().toString(), 2, '0')}:${(0, _padStart.default)(date.getSeconds().toString(), 2, '0')}.${(0, _padStart.default)(date.getMilliseconds().toString(), 3, '0')}`;
  }

  function getObserversCounter(query) {
    return query.observers.length;
  }

  function isQueryActive(query) {
    return query.observers.some(observer => observer.options.enabled !== false);
  }

  function makeQuerySelectionKey(query) {
    const key = `${(0, _nanoid.nanoid)(10)}-${query.queryHash}`;
    return key;
  }

  function isStale(query) {
    var _query$observers;

    const hasStaleObserver = (_query$observers = query.observers) === null || _query$observers === void 0 ? void 0 : _query$observers.some(observer => {
      var _observer$currentResu;

      return observer === null || observer === void 0 ? void 0 : (_observer$currentResu = observer.currentResult) === null || _observer$currentResu === void 0 ? void 0 : _observer$currentResu.isStale;
    });
    const hasInvalidState = query.state.isInvalidated || !query.state.dataUpdatedAt;
    return hasStaleObserver || hasInvalidState;
  }

  function isInactive(query) {
    return getObserversCounter(query) === 0;
  }

  function getQueryStatusLabel(query) {
    return query.state.isFetching ? 'fetching' : isInactive(query) ? 'inactive' : isStale(query) ? 'stale' : 'fresh';
  }
},3,[4,35],"src/utils/index.ts");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var createPadding = _$$_REQUIRE(_dependencyMap[0], "./_createPadding"),
      stringSize = _$$_REQUIRE(_dependencyMap[1], "./_stringSize"),
      toInteger = _$$_REQUIRE(_dependencyMap[2], "./toInteger"),
      toString = _$$_REQUIRE(_dependencyMap[3], "./toString");

  function padStart(string, length, chars) {
    string = toString(string);
    length = toInteger(length);
    var strLength = length ? stringSize(string) : 0;
    return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
  }

  module.exports = padStart;
},4,[5,21,28,34],"../../node_modules/lodash/padStart.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseRepeat = _$$_REQUIRE(_dependencyMap[0], "./_baseRepeat"),
      baseToString = _$$_REQUIRE(_dependencyMap[1], "./_baseToString"),
      castSlice = _$$_REQUIRE(_dependencyMap[2], "./_castSlice"),
      hasUnicode = _$$_REQUIRE(_dependencyMap[3], "./_hasUnicode"),
      stringSize = _$$_REQUIRE(_dependencyMap[4], "./_stringSize"),
      stringToArray = _$$_REQUIRE(_dependencyMap[5], "./_stringToArray");

  var nativeCeil = Math.ceil;

  function createPadding(length, chars) {
    chars = chars === undefined ? ' ' : baseToString(chars);
    var charsLength = chars.length;

    if (charsLength < 2) {
      return charsLength ? baseRepeat(chars, length) : chars;
    }

    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
    return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
  }

  module.exports = createPadding;
},5,[6,7,18,20,21,25],"../../node_modules/lodash/_createPadding.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var MAX_SAFE_INTEGER = 9007199254740991;
  var nativeFloor = Math.floor;

  function baseRepeat(string, n) {
    var result = '';

    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }

    do {
      if (n % 2) {
        result += string;
      }

      n = nativeFloor(n / 2);

      if (n) {
        string += string;
      }
    } while (n);

    return result;
  }

  module.exports = baseRepeat;
},6,[],"../../node_modules/lodash/_baseRepeat.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Symbol = _$$_REQUIRE(_dependencyMap[0], "./_Symbol"),
      arrayMap = _$$_REQUIRE(_dependencyMap[1], "./_arrayMap"),
      isArray = _$$_REQUIRE(_dependencyMap[2], "./isArray"),
      isSymbol = _$$_REQUIRE(_dependencyMap[3], "./isSymbol");

  var INFINITY = 1 / 0;
  var symbolProto = Symbol ? Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }

    if (isArray(value)) {
      return arrayMap(value, baseToString) + '';
    }

    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }

  module.exports = baseToString;
},7,[8,11,12,13],"../../node_modules/lodash/_baseToString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var root = _$$_REQUIRE(_dependencyMap[0], "./_root");

  var Symbol = root.Symbol;
  module.exports = Symbol;
},8,[9],"../../node_modules/lodash/_Symbol.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var freeGlobal = _$$_REQUIRE(_dependencyMap[0], "./_freeGlobal");

  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  module.exports = root;
},9,[10],"../../node_modules/lodash/_root.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
  module.exports = freeGlobal;
},10,[],"../../node_modules/lodash/_freeGlobal.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  module.exports = arrayMap;
},11,[],"../../node_modules/lodash/_arrayMap.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var isArray = Array.isArray;
  module.exports = isArray;
},12,[],"../../node_modules/lodash/isArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseGetTag = _$$_REQUIRE(_dependencyMap[0], "./_baseGetTag"),
      isObjectLike = _$$_REQUIRE(_dependencyMap[1], "./isObjectLike");

  var symbolTag = '[object Symbol]';

  function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }

  module.exports = isSymbol;
},13,[14,17],"../../node_modules/lodash/isSymbol.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Symbol = _$$_REQUIRE(_dependencyMap[0], "./_Symbol"),
      getRawTag = _$$_REQUIRE(_dependencyMap[1], "./_getRawTag"),
      objectToString = _$$_REQUIRE(_dependencyMap[2], "./_objectToString");

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  module.exports = baseGetTag;
},14,[8,15,16],"../../node_modules/lodash/_baseGetTag.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var Symbol = _$$_REQUIRE(_dependencyMap[0], "./_Symbol");

  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  module.exports = getRawTag;
},15,[8],"../../node_modules/lodash/_getRawTag.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;

  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  module.exports = objectToString;
},16,[],"../../node_modules/lodash/_objectToString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  module.exports = isObjectLike;
},17,[],"../../node_modules/lodash/isObjectLike.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseSlice = _$$_REQUIRE(_dependencyMap[0], "./_baseSlice");

  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }

  module.exports = castSlice;
},18,[19],"../../node_modules/lodash/_castSlice.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  module.exports = baseSlice;
},19,[],"../../node_modules/lodash/_baseSlice.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';
  var rsZWJ = '\\u200d';
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');

  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  module.exports = hasUnicode;
},20,[],"../../node_modules/lodash/_hasUnicode.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var asciiSize = _$$_REQUIRE(_dependencyMap[0], "./_asciiSize"),
      hasUnicode = _$$_REQUIRE(_dependencyMap[1], "./_hasUnicode"),
      unicodeSize = _$$_REQUIRE(_dependencyMap[2], "./_unicodeSize");

  function stringSize(string) {
    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
  }

  module.exports = stringSize;
},21,[22,20,24],"../../node_modules/lodash/_stringSize.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseProperty = _$$_REQUIRE(_dependencyMap[0], "./_baseProperty");

  var asciiSize = baseProperty('length');
  module.exports = asciiSize;
},22,[23],"../../node_modules/lodash/_asciiSize.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  module.exports = baseProperty;
},23,[],"../../node_modules/lodash/_baseProperty.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';
  var rsAstral = '[' + rsAstralRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ = '\\u200d';
  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;

    while (reUnicode.test(string)) {
      ++result;
    }

    return result;
  }

  module.exports = unicodeSize;
},24,[],"../../node_modules/lodash/_unicodeSize.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var asciiToArray = _$$_REQUIRE(_dependencyMap[0], "./_asciiToArray"),
      hasUnicode = _$$_REQUIRE(_dependencyMap[1], "./_hasUnicode"),
      unicodeToArray = _$$_REQUIRE(_dependencyMap[2], "./_unicodeToArray");

  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }

  module.exports = stringToArray;
},25,[26,20,27],"../../node_modules/lodash/_stringToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function asciiToArray(string) {
    return string.split('');
  }

  module.exports = asciiToArray;
},26,[],"../../node_modules/lodash/_asciiToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';
  var rsAstral = '[' + rsAstralRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ = '\\u200d';
  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  module.exports = unicodeToArray;
},27,[],"../../node_modules/lodash/_unicodeToArray.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var toFinite = _$$_REQUIRE(_dependencyMap[0], "./toFinite");

  function toInteger(value) {
    var result = toFinite(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  module.exports = toInteger;
},28,[29],"../../node_modules/lodash/toInteger.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var toNumber = _$$_REQUIRE(_dependencyMap[0], "./toNumber");

  var INFINITY = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;

  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber(value);

    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }

  module.exports = toFinite;
},29,[30],"../../node_modules/lodash/toFinite.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseTrim = _$$_REQUIRE(_dependencyMap[0], "./_baseTrim"),
      isObject = _$$_REQUIRE(_dependencyMap[1], "./isObject"),
      isSymbol = _$$_REQUIRE(_dependencyMap[2], "./isSymbol");

  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol(value)) {
      return NAN;
    }

    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  module.exports = toNumber;
},30,[31,33,13],"../../node_modules/lodash/toNumber.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var trimmedEndIndex = _$$_REQUIRE(_dependencyMap[0], "./_trimmedEndIndex");

  var reTrimStart = /^\s+/;

  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
  }

  module.exports = baseTrim;
},31,[32],"../../node_modules/lodash/_baseTrim.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var reWhitespace = /\s/;

  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}

    return index;
  }

  module.exports = trimmedEndIndex;
},32,[],"../../node_modules/lodash/_trimmedEndIndex.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  module.exports = isObject;
},33,[],"../../node_modules/lodash/isObject.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var baseToString = _$$_REQUIRE(_dependencyMap[0], "./_baseToString");

  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  module.exports = toString;
},34,[7],"../../node_modules/lodash/toString.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.random = exports.nanoid = exports.customRandom = exports.customAlphabet = void 0;
  Object.defineProperty(exports, "urlAlphabet", {
    enumerable: true,
    get: function () {
      return _index.urlAlphabet;
    }
  });

  var _crypto = _interopRequireDefault(electronRequire("crypto"));

  var _index = _$$_REQUIRE(_dependencyMap[0], "./url-alphabet/index.js");

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  const POOL_SIZE_MULTIPLIER = 128;
  let pool, poolOffset;

  let fillPool = bytes => {
    if (!pool || pool.length < bytes) {
      pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);

      _crypto.default.randomFillSync(pool);

      poolOffset = 0;
    } else if (poolOffset + bytes > pool.length) {
      _crypto.default.randomFillSync(pool);

      poolOffset = 0;
    }

    poolOffset += bytes;
  };

  let random = bytes => {
    fillPool(bytes -= 0);
    return pool.subarray(poolOffset - bytes, poolOffset);
  };

  exports.random = random;

  let customRandom = (alphabet, size, getRandom) => {
    let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
    let step = Math.ceil(1.6 * mask * size / alphabet.length);
    return () => {
      let id = '';

      while (true) {
        let bytes = getRandom(step);
        let i = step;

        while (i--) {
          id += alphabet[bytes[i] & mask] || '';
          if (id.length === size) return id;
        }
      }
    };
  };

  exports.customRandom = customRandom;

  let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random);

  exports.customAlphabet = customAlphabet;

  let nanoid = (size = 21) => {
    fillPool(size -= 0);
    let id = '';

    for (let i = poolOffset - size; i < poolOffset; i++) {
      id += _index.urlAlphabet[pool[i] & 63];
    }

    return id;
  };

  exports.nanoid = nanoid;
},35,[36],"../../node_modules/nanoid/index.js");
__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.urlAlphabet = void 0;
  let urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
  exports.urlAlphabet = urlAlphabet;
},36,[],"../../node_modules/nanoid/url-alphabet/index.js");
module.exports = global.__r(0);
//# sourceMappingURL=/Users/bruno/Projects/bgaleotti/react-query-native-devtools/packages/flipper-plugin-react-query-native-devtools/dist/bundle.map